What was the problem you were solving in the projects for this course?
In Project One, I needed to analyze how different data structures handle runtime and memory efficiency when managing course data. For Project Two, the goal was to build a program that could load course data, sort it in alphanumeric order, and display it clearly for users.

How did you approach the problem?
I focused on understanding why the choice of data structures matters so much. It’s not just about making the code work, it’s about making it work efficiently. Project One, I dove into comparing vectors, hash tables, and binary search trees, breaking down their strengths and weaknesses. For Project Two, I decided to use a map (hash table) because it’s great for fast lookups and sorting, which fit the project requirements perfectly.

How did you overcome roadblocks?
Let’s just say debugging was a bit of an adventure. File handling was difficult at first, and getting the alphanumeric sorting to behave took some tweaking. I worked through it by breaking the problems into smaller pieces, testing along the way, and leaning on things like step-by-step debugging and sample inputs to figure out where the code wasn’t doing what it should.

How has your work on this project expanded your approach to designing software and developing programs?
These projects really opened my eyes to how critical the "right tools for the job" mindset is in software design. I’ve learned to think more about the big picture, balancing speed, memory usage, and scalability. It’s not just about solving the problem in front of me but about designing solutions that make sense in the long run.

How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?
I’ve started putting more thought into how I structure my code, modular functions, meaningful variable names, and comments where it counts. It’s all about writing code that future-me (or anyone else) can read without scratching their head. These projects helped me realize that maintainability and adaptability aren’t extras, they’re essential parts of good programming.
